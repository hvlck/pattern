package pattern

import (
	"bytes"
	"io"
	"reflect"
	"strings"

	"golang.org/x/net/html"
)

// Extraneous elements, not weighted
var EXCLUDED_ELEMENTS = []struct {
	name  string
	attrs map[string]bool
}{
	{name: "head"},
	{name: "body"},
	{
		name: "meta",
		attrs: map[string]bool{
			"charset": true,
		},
	},
	{name: "br"},
}

var EXCLUDED_ATTRS = []string{}

// Compares two HTML documents. Returns a list of differing nodes, a float representing the similarity
// between the two, and an error, if applicable.
func Compare(one, two []byte) ([][]html.Token, float64, error) {
	var score float64 = 1
	different := [][]html.Token{}

	o := html.NewTokenizer(bytes.NewReader(one))
	t := html.NewTokenizer(bytes.NewReader(two))

	for {
		oTokType := o.Next()
		if oTokType == html.ErrorToken {
			if t.Err() == io.EOF {
				break
			}

			return nil, score, t.Err()
		}

		tTokType := t.Next()
		if tTokType == html.ErrorToken {
			if t.Err() == io.EOF {
				break
			}

			return nil, score, t.Err()
		}

		oTok := o.Token()
		tTok := t.Token()

		// only care about the start of html elements and the text they contain
		if oTok.Type != html.StartTagToken && oTok.Type != html.TextToken {
			continue
		}

		if tTok.Type != html.StartTagToken && tTok.Type != html.TextToken {
			continue
		}

		// checks whether the token is whitespace
		// can definitely be improved, but primarily used to strip excess whitespace
		// generated by HTML prettifiers.
		if oTok.Type == html.TextToken {
			d := strings.ReplaceAll(strings.ReplaceAll(oTok.Data, " ", ""), "\n", "")
			if len(d) == 0 {
				continue
			}
		}

		if tTok.Type == html.TextToken {
			d := strings.ReplaceAll(strings.ReplaceAll(tTok.Data, " ", ""), "\n", "")
			if len(d) == 0 {
				continue
			}
		}

		// checks whether the given token is excluded
		if oTok.Type == html.StartTagToken || tTok.Type == html.StartTagToken {
			for _, v := range EXCLUDED_ELEMENTS {
				if isElement(oTok, v.name, v.attrs) || isElement(tTok, v.name, v.attrs) {
					continue
				}
			}
		}

		// cheap trick
		if reflect.DeepEqual(oTok, tTok) {
			continue
		} else {
			score *= difference(oTok, tTok).Weight()

			diff := []html.Token{oTok, tTok}
			different = append(different, diff)
		}
	}

	return different, score, nil
}

// Checks whether the given token is of type `name`. If attrs is specified, isElement will only return true
// if all attributes are present (but does not check whether they match a value).
func isElement(one html.Token, name string, attrs map[string]bool) bool {
	if one.Type == html.StartTagToken && one.Data == name {
		if len(attrs) != 0 {
			f := len(attrs)
			for _, v := range one.Attr {
				if _, ok := attrs[v.Key]; ok {
					f--
				}
			}

			return f == 0
		}
		return true
	}

	return false
}

// Represents a difference between two HTML documents.
type Difference string

var (
	// Text content differs
	Text Difference = "text"
	// Element placement differs
	Element Difference = "element"
	// Attribute value/existence differs
	Attr Difference = "attribute"
)

// Weights used for ranking page similarity.
var WEIGHTS = map[Difference]float64{
	Text:    0.99,
	Element: 0.98,
	Attr:    0.999,
}

// Returns the weight of the given difference
func (d Difference) Weight() float64 {
	return WEIGHTS[d]
}

// Returns the difference between two html tokens.
func difference(one, two html.Token) Difference {
	if one.Type != two.Type || one.Data != two.Data {
		return Element
	}

	if one.Type == html.TextToken && two.Type == html.TextToken {
		if one.Data != two.Data {
			return Text
		}
	}

	for _, i := range one.Attr {
		for _, j := range two.Attr {
			if i.Key != j.Key && i.Val != j.Key {
				return Attr
			}
		}
	}

	return Attr
}
